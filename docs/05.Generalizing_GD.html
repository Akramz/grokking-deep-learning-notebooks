---

title: Learning Multiple Weights at a Time: Generalizing Gradient Descent
keywords: fastai
sidebar: home_sidebar


---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: 05.Generalizing_GD.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
    
<div class="cell border-box-sizing code_cell rendered">

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>In This Chapter:</p>
<ul>
<li>Gradient Descent Learning with multiple Inputs</li>
<li>Freezing One Weight: One does it do?</li>
<li>Gradient Descent Learning with Multiple Outputs</li>
<li>Gradeint Descent Learning with Multiple Inputs and Outputs</li>
<li>Visualizing Weight Values</li>
<li>Visualizing Dot Products</li>
</ul>
<blockquote><p>"You don't learn to walk by following rules. You learn by doing and by falling over." - Richard Branson</p>
</blockquote>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Gradient-Descent-Learning-with-Multiple-Inputs">Gradient Descent Learning with Multiple Inputs<a class="anchor-link" href="#Gradient-Descent-Learning-with-Multiple-Inputs">&#182;</a></h2><h3 id="Gradient-Descent-Also-works-with-Multiple-Inputs">Gradient Descent Also works with Multiple Inputs<a class="anchor-link" href="#Gradient-Descent-Also-works-with-Multiple-Inputs">&#182;</a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>{% include image.html style="width:500px" file="static/imgs/06/many-to-one.png" %}</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># an empty network with multiple inputs.</span>
<span class="k">def</span> <span class="nf">w_sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
    <span class="n">S</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)):</span>
        <span class="n">S</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">S</span>

<span class="c1"># init weights.</span>
<span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="o">.</span><span class="mi">2</span><span class="p">,</span> <span class="o">-.</span><span class="mi">1</span><span class="p">]</span>

<span class="c1"># defining the model.</span>
<span class="k">def</span> <span class="nf">neural_network</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
    <span class="n">prediction</span> <span class="o">=</span> <span class="n">w_sum</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">prediction</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># PREDICT + COMPARE: Making a Prediction, and Calculating Error &amp; Delta.</span>
<span class="n">toes</span> <span class="o">=</span> <span class="p">[</span><span class="mf">8.5</span><span class="p">,</span> <span class="mf">9.5</span><span class="p">,</span> <span class="mf">9.9</span><span class="p">,</span> <span class="mf">9.0</span><span class="p">]</span>
<span class="n">wlrec</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.65</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">]</span>
<span class="n">nfans</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.3</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>

<span class="n">win_or_lose_binary</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

<span class="n">true</span> <span class="o">=</span> <span class="n">win_or_lose_binary</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="nb">input</span> <span class="o">=</span> <span class="p">[</span><span class="n">toes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">wlrec</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nfans</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

<span class="n">pred</span> <span class="o">=</span> <span class="n">neural_network</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>

<span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">pred</span> <span class="o">-</span> <span class="n">true</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
<span class="n">delta</span> <span class="o">=</span> <span class="n">pred</span> <span class="o">-</span> <span class="n">true</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># LEARN: Calculating each weight_delta and putting it on each weight</span>
<span class="k">def</span> <span class="nf">ele_mul</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="n">vector</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">number</span> <span class="o">*</span> <span class="n">v_i</span> <span class="k">for</span> <span class="n">v_i</span> <span class="ow">in</span> <span class="n">vector</span><span class="p">]</span>

<span class="c1"># we calculate gradients associated w/ each weight.</span>
<span class="n">gradients</span> <span class="o">=</span> <span class="n">ele_mul</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="nb">input</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">gradients</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># LEARN: Updating the Weights.</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="o">.</span><span class="mi">01</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">)):</span>
    <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">gradients</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    
<span class="nb">print</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">gradients</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>[0.1119, 0.20091, -0.09832]
[-1.189999999999999, -0.09099999999999994, -0.16799999999999987]
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Gradient-Descent-with-Multiple-Inputs-Exaplained">Gradient Descent with Multiple Inputs Exaplained<a class="anchor-link" href="#Gradient-Descent-with-Multiple-Inputs-Exaplained">&#182;</a></h2><h3 id="Simple-to-Execute,-and-Fascinating-to-Understand">Simple to Execute, and Fascinating to Understand<a class="anchor-link" href="#Simple-to-Execute,-and-Fascinating-to-Understand">&#182;</a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>The Properties involved are fascinating and worthy of discussion</li>
<li>Let's take a look at them side by side:</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Single Input: Making a Prediction and calculating error and delta.</span>
<span class="n">number_of_toes</span> <span class="o">=</span> <span class="p">[</span><span class="mf">8.5</span><span class="p">]</span>
<span class="n">win_or_lose_binary</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<span class="nb">input</span> <span class="o">=</span> <span class="n">number_of_toes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">true</span> <span class="o">=</span> <span class="n">win_or_lose_binary</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">weight</span> <span class="o">=</span> <span class="mf">0.3</span>

<span class="n">prediction</span> <span class="o">=</span> <span class="nb">input</span> <span class="o">*</span> <span class="n">weight</span>
<span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">prediction</span> <span class="o">-</span> <span class="n">true</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
<span class="n">gradient</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">input</span> <span class="o">*</span> <span class="p">(</span><span class="n">prediction</span> <span class="o">-</span> <span class="n">true</span><span class="p">)</span>
<span class="n">delta</span> <span class="o">=</span> <span class="n">prediction</span> <span class="o">-</span> <span class="n">true</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="How-do-you-turn-a-single-delta-(on-the-node)-into-three-weight-delta-values?">How do you turn a single delta (on the node) into three weight delta values?<a class="anchor-link" href="#How-do-you-turn-a-single-delta-(on-the-node)-into-three-weight-delta-values?">&#182;</a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>{% include image.html style="width:66%;" file="static/imgs/06/Conversation.png" %}</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Let's-Watch-several-steps-of-learning">Let's Watch several steps of learning<a class="anchor-link" href="#Let's-Watch-several-steps-of-learning">&#182;</a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>{% include image.html style="width:66%;" file="static/imgs/06/Iteration_1.png" %}</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>We can make three individual error/weight curves, on for each weight.</li>
<li>The Slopes of these curves are reflected by the gradient values.</li>
<li>Why is the gradient steeper for (a) than the others if they share the same prediction and error.<ul>
<li>Because (a) has an input value that's significantly higher than the others and thus, a higher derivative.</li>
</ul>
</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>{% include image.html style="width:66%;" file="static/imgs/06/Iteration_2.png" %}</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>Most of the learning (weight changing) was performaed on the weight with the largest input.<ul>
<li>Because the input changes the slope significantly.</li>
</ul>
</li>
<li>This isn't necessarily advantageous in all settings.<ul>
<li>A subfield called <em>normalization</em> helps encourage learning across all weights despite dataset characteristics such as this.</li>
</ul>
</li>
<li>This significant difference in slope forced me to set alpha lower than i wanted.(.01 instead of .1)</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Freezing-one-weight:-What-does-it-do?">Freezing one weight: What does it do?<a class="anchor-link" href="#Freezing-one-weight:-What-does-it-do?">&#182;</a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>This experiment is a bit advanced in terms of theory.<ul>
<li>But i think it's a great exercise to understand how the weights effect each other.</li>
</ul>
</li>
<li>you're going to train again, except weight (a) won't ever be adjusted.<ul>
<li>You'll try to learn the training example using only weights (b) and (c).</li>
</ul>
</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">lr</span> <span class="o">=</span> <span class="o">.</span><span class="mi">3</span>

<span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
    <span class="n">pred</span> <span class="o">=</span> <span class="n">neural_network</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
    
    <span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">pred</span> <span class="o">-</span> <span class="n">true</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">pred</span> <span class="o">-</span> <span class="n">true</span><span class="p">)</span>
    
    <span class="n">gradients</span> <span class="o">=</span> <span class="n">ele_mul</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="nb">input</span><span class="p">)</span>
    <span class="n">gradients</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Iteration : &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">iter</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Pred : &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">pred</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error : &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Weights : &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">weights</span><span class="p">))</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">)):</span>
        <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="n">lr</span> <span class="o">*</span> <span class="n">gradients</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Iteration : 0
Pred : 0.8600000000000001
Error : 0.01959999999999997
Weights : [0.1, 0.2, -0.1]
Iteration : 1
Pred : 0.9382250000000001
Error : 0.003816150624999989
Weights : [0.1, 0.2273, -0.04960000000000005]
Iteration : 2
Pred : 0.97274178125
Error : 0.000743010489422852
Weights : [0.1, 0.239346125, -0.02736100000000008]
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>{% include image.html style="width:30%" file="static/imgs/06/Experiment_1.png" %}</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Gradient-Descent-Learning-with-Multiple-Outputs">Gradient Descent Learning with Multiple Outputs<a class="anchor-link" href="#Gradient-Descent-Learning-with-Multiple-Outputs">&#182;</a></h2><h3 id="Neural-Networks-can-also-make-multiple-predictions-using-only-a-single-input">Neural Networks can also make multiple predictions using only a single input<a class="anchor-link" href="#Neural-Networks-can-also-make-multiple-predictions-using-only-a-single-input">&#182;</a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>At this Point, I hope it's clear that a simple mechanism (stochastic gradient descent) is constantly used to perform learning across a wide veriety of architectures.</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># An empty network with multiple outputs.</span>
<span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="o">.</span><span class="mi">3</span><span class="p">,</span> <span class="o">.</span><span class="mi">2</span><span class="p">,</span> <span class="o">.</span><span class="mi">9</span><span class="p">]</span>
<span class="k">def</span> <span class="nf">neural_network</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
    <span class="n">prediction</span> <span class="o">=</span> <span class="n">ele_mul</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">prediction</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># PREDICT: Making a prediction and calculating error and delta.</span>
<span class="n">wlrec</span> <span class="o">=</span> <span class="p">[</span><span class="o">.</span><span class="mi">65</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">.</span><span class="mi">9</span><span class="p">]</span>
<span class="n">hurt</span> <span class="o">=</span> <span class="p">[</span><span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">]</span>
<span class="n">win</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">sad</span> <span class="o">=</span> <span class="p">[</span><span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="o">.</span><span class="mi">2</span><span class="p">]</span>

<span class="nb">input</span> <span class="o">=</span> <span class="n">wlrec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">target</span> <span class="o">=</span> <span class="p">[</span><span class="n">hurt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">win</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sad</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

<span class="n">pred</span> <span class="o">=</span> <span class="n">neural_network</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>

<span class="n">error</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">pure_error</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">target</span><span class="p">)):</span>
    <span class="n">error</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">pred</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">target</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">pure_error</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pred</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">target</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">pred</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">pure_error</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>([0.195, 0.13, 0.5850000000000001],
 [0.009025, 0.7569, 0.2352250000000001],
 [0.095, -0.87, 0.4850000000000001])</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># COMPARE: Calculating each gradient.</span>
<span class="n">gradients</span> <span class="o">=</span> <span class="p">[</span><span class="nb">input</span> <span class="o">*</span> <span class="n">pure_error</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">input</span> <span class="o">*</span> <span class="n">pure_error</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">input</span> <span class="o">*</span> <span class="n">pure_error</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># UPDATE: Updating the Weights.</span>
<span class="n">lr</span> <span class="o">=</span> <span class="mi">3</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">)):</span>
    <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="n">lr</span> <span class="o">*</span> <span class="n">gradients</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="p">[</span><span class="nb">input</span> <span class="o">*</span> <span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">weights</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>[0.07458749999999997, 1.2327249999999998, -0.02973750000000019]</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Gradient-Descent-with-Multiple-Inputs-&amp;-Outputs">Gradient Descent with Multiple Inputs &amp; Outputs<a class="anchor-link" href="#Gradient-Descent-with-Multiple-Inputs-&amp;-Outputs">&#182;</a></h2><h3 id="Gradient-Descent-generalizes-to-arbitrary-large-networks">Gradient Descent generalizes to arbitrary large networks<a class="anchor-link" href="#Gradient-Descent-generalizes-to-arbitrary-large-networks">&#182;</a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>{% include image.html style="width:25%" file="static/imgs/06/many-to-many.png" %}</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># 1. An empty Network with multiple inputs and outputs.</span>
<span class="n">weights</span> <span class="o">=</span> <span class="p">[[</span><span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="o">-.</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="o">.</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.3</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">]]</span>

<span class="k">def</span> <span class="nf">vect_mat_mul</span><span class="p">(</span><span class="n">vect</span><span class="p">,</span> <span class="n">matrix</span><span class="p">):</span>
    <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vect</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">))</span>
    <span class="n">output</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vect</span><span class="p">)):</span>
        <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">w_sum</span><span class="p">(</span><span class="n">vect</span><span class="p">,</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">output</span>

<span class="k">def</span> <span class="nf">neural_network</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
    <span class="n">prediction</span> <span class="o">=</span> <span class="n">vect_mat_mul</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">prediction</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># 2. PREDICT: Making a Prediction &amp; Calculating Error &amp; Delta (Pure Error).</span>

<span class="c1"># Inputs.</span>
<span class="n">toes</span> <span class="o">=</span> <span class="p">[</span><span class="mf">8.5</span><span class="p">,</span> <span class="mf">9.5</span><span class="p">,</span> <span class="mf">9.9</span><span class="p">,</span> <span class="mf">9.0</span><span class="p">]</span>
<span class="n">wlrec</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.65</span><span class="p">,</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">]</span>
<span class="n">nfans</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.3</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>

<span class="c1"># Outputs.</span>
<span class="n">hurt</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]</span>
<span class="n">win</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">sad</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">]</span>

<span class="c1"># learning rate.</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="o">.</span><span class="mi">01</span>

<span class="nb">input</span> <span class="o">=</span> <span class="p">[</span><span class="n">toes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">wlrec</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nfans</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
<span class="n">target</span> <span class="o">=</span> <span class="p">[</span><span class="n">hurt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">win</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sad</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

<span class="n">prediction</span> <span class="o">=</span> <span class="n">neural_network</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
<span class="n">error</span><span class="p">,</span> <span class="n">delta</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">prediction</span><span class="p">)):</span>
    <span class="n">error</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">prediction</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">target</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">prediction</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">target</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># 3. COMPARE: Calculating each weight_delta &amp; Putting it on each weight.</span>

<span class="c1"># we have 9 gradients, or weight deltas.</span>
<span class="k">def</span> <span class="nf">outer_prod</span><span class="p">(</span><span class="n">vect_a</span><span class="p">,</span> <span class="n">vect_b</span><span class="p">):</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">vect_a</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">vect_b</span><span class="p">)))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vect_a</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vect_b</span><span class="p">)):</span>
            <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">vect_a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">vect_b</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">out</span>

<span class="n">gradients</span> <span class="o">=</span> <span class="n">outer_prod</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># 4. LEARN: Updating the Weights</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">)):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
        <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">-=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">gradients</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="What-Do-These-weights-Learn?">What Do These weights Learn?<a class="anchor-link" href="#What-Do-These-weights-Learn?">&#182;</a></h2><h3 id="Each-Weight-Tries-to-reduce-the-Error,-But-what-do-they-learn-in-aggregate?">Each Weight Tries to reduce the Error, But what do they learn in aggregate?<a class="anchor-link" href="#Each-Weight-Tries-to-reduce-the-Error,-But-what-do-they-learn-in-aggregate?">&#182;</a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>Congratulations! This is the part of the book where we move on to the first real-world dataset.<ul>
<li>As Luck would have it, <strong>It's one with historical significance</strong>.</li>
</ul>
</li>
<li>It's called the modified national institute of standards and technology (MNIST) dataset.<ul>
<li>It consits of digits that high school students and employees of the US census bureau wrote some years ago.</li>
<li>The interesting thing is that these images are black-and-white images of people's handwriting.</li>
<li>Accompanying each digit is the actual number they were writing (0-9).</li>
</ul>
</li>
<li>Each Image is 784 pixels (28x28).</li>
<li>Each Training example contain 784 values.<ul>
<li>So the neural network must have 784 input values.</li>
</ul>
</li>
<li><strong>You want to predict 10 probabilities</strong><ul>
<li>One for each digit.</li>
<li>the neural network tells you which digit is most likely to be what was drawn.</li>
</ul>
</li>
<li>Let's Take a look at the MNIST Dataset:</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">keras</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stderr output_text">
<pre>Using TensorFlow backend.
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">keras.datasets</span> <span class="kn">import</span> <span class="n">mnist</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">),</span> <span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span> <span class="o">=</span> <span class="n">mnist</span><span class="o">.</span><span class="n">load_data</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># let&#39;s take a sample.</span>
<span class="n">images</span> <span class="o">=</span> <span class="n">X_train</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1000</span><span class="p">]</span>
<span class="n">labels</span> <span class="o">=</span> <span class="n">y_train</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1000</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">images</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">labels</span><span class="o">.</span><span class="n">shape</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>((1000, 28, 28), (1000,))</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>{% include image.html style="width:50%" file="static/imgs/06/MNIST_clear_model.png" %}</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Visualizing-Weight-Values">Visualizing Weight Values<a class="anchor-link" href="#Visualizing-Weight-Values">&#182;</a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>{% include image.html style="width:33%" file="static/imgs/06/MNIST_weight_visualization.png" %}</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Visualizing-Dot-Products-(Weighted-Sums)">Visualizing Dot Products (Weighted Sums)<a class="anchor-link" href="#Visualizing-Dot-Products-(Weighted-Sums)">&#182;</a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># remember that the dot product is a mathematical measure of similarity.</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">a</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>0</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>{% include image.html style="width:50%" file="static/imgs/06/Neural_Similarity.png" %}</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Summary">Summary<a class="anchor-link" href="#Summary">&#182;</a></h2><h3 id="Gradient-Descent-is-a-General-Learning-Algorithm">Gradient Descent is a General Learning Algorithm<a class="anchor-link" href="#Gradient-Descent-is-a-General-Learning-Algorithm">&#182;</a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>The Most important Subtext of this chapter is that gradient descent is a very flexible learning algorithm.</li>
<li>If you Combine weights in a way that allows you to calculate an error function and a delta, gradient descent can show you how to reduce error.</li>
<li>We'll spend the rest of this book exploring different types of weight combinations &amp; Error Functions for which gradient descent is useful.</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Sketches">Sketches<a class="anchor-link" href="#Sketches">&#182;</a></h1>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>{% include image.html style="width:333px" file="static/imgs/06/0.jpg" %}</p>

</div>
</div>
</div>
</div>
 

